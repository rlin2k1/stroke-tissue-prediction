# :: image_processing.py
#####################################################
# Functions to handle processing the raw DCM images.
#####################################################
# :: Created By: Benji Brandt <benjibrandt@ucla.edu>, 
#                Roy Lin <rlin2k1@gmail.com>, 
#                David Macaraeg <dmacaraeg@g.ucla.edu>
# :: Creation Date: 15 May 2019


import sys, os
from random import sample
from collections import defaultdict
from operator import itemgetter

import pydicom


def random_sample_pixel_map(pixel_map, number_of_samples):
    """
    Randomly samples the provided pixel map to obtain number_of_samples coordinates.

    :param dict pixel_map: a key-value storage of coordinates to pixel values.
    :param int number_of_samples: the number of samples we wish to obtain.
    :return: a dictionary comprised of number_of_samples randomly-selected key-value pairs from pixel_map.
    :rtype: dict
    """
    keys = sample(pixel_map.keys(), number_of_samples)
    return {k: v for (k, v) in pixel_map.items() if k in keys}


def _sort_and_clean_slice_dict(slice_dict):
    """
    Sorts the nested pixel arrays within {slice_id: {coord: pixel_arr}}-type dictionaries.
    Then use dictionary comprehension to remove the time data from pixel_arrs, turning [(time, val), (time, val)] into [val, val]

    :param dict slice_dict: a dict of the form {slice_id: {coord: pixel_arr}}.
    :return: the same dictionary, but with the (time, val) tuples in pixel_arrs replaced just by their values, after being sorted via time.
    :rtpye: dict
    """
    for coordinate_dict in slice_dict.values():
        for pixel_arr in coordinate_dict.values():
            pixel_arr.sort(key=itemgetter(0))
    return {slice_id: {coord: [i_val for (_, i_val) in intensity_arr] for (coord, intensity_arr) in coord_dict.items()} for (slice_id, coord_dict) in slice_dict.items()}


def parse_dcm_data(directory_name):
    """
    Parses all DCMs within list of files, creating a mapping between patient_id, pixel coordinates, and pixel intensity over time.

    :param directory_name: the name of a directory with DCM files to examine.
    :return: a dictionary in the following form: {slice_id: {pixel_coordinate: array_of_pixel_values_over_time}}
    :rtpye: dict
    """
    slice_dict = {}
    for file in os.listdir(directory_name):
        if file.endswith(".dcm"):
            dcm = pydicom.dcmread(os.path.join(directory_name, file))
            if dcm.SliceLocation in slice_dict.keys():
                map_pixel_data(dcm.pixel_array, dcm.InstanceCreationTime, slice_dict[dcm.SliceLocation])
            else:
                slice_dict[dcm.SliceLocation] = map_pixel_data(dcm.pixel_array, dcm.InstanceCreationTime)
    return _sort_and_clean_slice_dict(slice_dict)


def map_pixel_data(pixels, creation_time, slice_data = None, ignore_zero_intensity = True):
    """
    Creates a dictionary of pixel coordinates to pixel values.

    :param list pixels: a list of lists, where each sublist is a 2-d array of pixels generated by pydicom's pixel_array for a specific time slice.
    :param bool ignore_zero_intensity: if true, mappings won't be created for pixels which have 0 as their value.
    :return: a dictionary of image coordinates as the key, matched with pixel values as the value.
    :rtype: dict
    """
    if slice_data is None: slice_data = defaultdict(list)
    pixel_sz_x = len(pixels)
    for x in range(pixel_sz_x):
        for y in range(len(pixels[x])):
            if ignore_zero_intensity and pixels[x][y] == 0: 
                continue
            slice_data[(x, y)].append((creation_time, pixels[x][y]))
    return slice_data


if __name__ == '__main__':
    if len(sys.argv) == 2:
        print("Processing DCMs in directory: {}".format(sys.argv[1]))
        print(parse_dcm_data(str(sys.argv[1])))
    else:
        sys.exit("USAGE: python image_processing.py <directory with DCM files>")
